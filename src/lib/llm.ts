export async function callVegasLLM(provider: string, apiKey: string, prompt: string) {
    console.log(`[LLM] Calling live ${provider} API...`);

    const headers: Record<string, string> = {
        "Content-Type": "application/json",
    };

    let errorBody = "";

    try {
        if (provider === "chatgpt") {
            headers["Authorization"] = `Bearer ${apiKey}`;
            const res = await fetch("https://api.openai.com/v1/chat/completions", {
                method: "POST",
                headers,
                body: JSON.stringify({
                    model: "gpt-3.5-turbo",
                    messages: [{ role: "user", content: prompt }]
                })
            });
            if (!res.ok) {
                errorBody = await res.text();
                throw new Error(`OpenAI Error: ${res.status} ${res.statusText} - ${errorBody}`);
            }
            const data = await res.json();
            return data.choices[0].message.content;
        }
        else if (provider === "claude") {
            headers["x-api-key"] = apiKey;
            headers["anthropic-version"] = "2023-06-01";
            const res = await fetch("https://api.anthropic.com/v1/messages", {
                method: "POST",
                headers,
                body: JSON.stringify({
                    model: "claude-3-haiku-20240307",
                    max_tokens: 1024,
                    messages: [{ role: "user", content: prompt }]
                })
            });
            if (!res.ok) {
                errorBody = await res.text();
                throw new Error(`Anthropic Error: ${res.status} ${res.statusText} - ${errorBody}`);
            }
            const data = await res.json();
            return data.content[0].text;
        }
        else if (provider === "gemini") {
            // Using gemini-2.5-flash as 1.5 is deprecated as of 2026
            const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`;
            const res = await fetch(url, {
                method: "POST",
                headers,
                body: JSON.stringify({
                    contents: [{ parts: [{ text: prompt }] }]
                })
            });
            if (!res.ok) {
                errorBody = await res.text();
                throw new Error(`Gemini Error: ${res.status} ${res.statusText} - ${errorBody}`);
            }
            const data = await res.json();
            if (!data.candidates || data.candidates.length === 0) {
                throw new Error(`Gemini Error: No candidates returned. Safety filters might have blocked the response.`);
            }
            return data.candidates[0].content.parts[0].text;
        }
    } catch (error: any) {
        console.error(`[LLM Error] Provider ${provider} failed:`, error.message);
        throw new Error(`LLM Error (${provider}): ${error.message}`);
    }

    throw new Error(`Unknown LLM provider: ${provider}`);
}

export async function testLLMConnection(provider: string, apiKey: string) {
    const prompt = "Respond with exactly one word: 'READY'";
    const response = await callVegasLLM(provider, apiKey, prompt);
    return response.trim().toUpperCase().includes("READY");
}

export async function extractGitReposFromJira(provider: string, apiKey: string, description: string) {
    const prompt = `
Analyze this Jira description and extract three distinct things:
1. ANY git repository URLs mentioned (usually ending in .git, or standard git repo urls). List them on separate lines starting EXACTLY with "REPO: ". If none are found, say "REPO: NONE"
2. The overarching purpose of this program based on the description. Write it under the EXACT header "PURPOSE DO NOT REMOVE:".
3. Write standard BDD documentation summarizing the feature. Write it under the EXACT header "BDD DO NOT REMOVE:".

Jira Description:
${description}
`;

    const response = await callVegasLLM(provider, apiKey, prompt);

    // Regex to extract urls after REPO: 
    const repoMatches = response.match(/REPO:\s*(https?:\/\/[^\s]+)/gi) || [];
    const urls = repoMatches
        .map((r: string) => r.replace(/REPO:\s*/i, "").trim())
        .filter((url: string) => url !== "NONE" && url.length > 5);

    // Extract purpose and BDD from live response
    const purposeMatch = response.match(/PURPOSE DO NOT REMOVE:\s*([\s\S]*?)(?=\nBDD DO NOT REMOVE:|$)/i);
    const bddMatch = response.match(/BDD DO NOT REMOVE:\s*([\s\S]*)$/i);

    return {
        urls,
        purpose: purposeMatch ? purposeMatch[1].trim() : "Purpose not identified by LLM.",
        bdd: bddMatch ? bddMatch[1].trim() : "# BDD Docs\nNot generated by LLM."
    };
}
